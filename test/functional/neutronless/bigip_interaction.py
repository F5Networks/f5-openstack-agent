#!/usr/bin/env python
# Copyright 2017 F5 Networks Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import datetime
import os
import pytest
import subprocess

from collections import namedtuple
from time import sleep

ssh_cfg = os.environ.get('ssh_cfg', None)
if not ssh_cfg:
    ssh_cfg = '/home/ubuntu/testenv_symbols/testenv_ssh_config'
my_epoch = datetime.datetime.now().strftime('%Y%m%d%H%M%S')
current_test = ''  # should contain the current tests's name


"""Allows test interaction with the BIG-IP

    This module holds classes and tools used for the control of the BIG-IP
    config via backup and restore for test pollution prevention purposes.

    For use outside of testenv:
        In order to use this outside of testenv, the user should set the bash
        env variable:
            export ssh_cfg=/path/to/.ssh/config
        It should also be noted that this setup assumes a few things:
            1. That the handshakes and any key sharing is performed before
                runtime
            2. That the key-add to the shared key has already been performed

    Diff files will be generated by `which diff` linux-builtin app.  These diff
    results will be stored within /tmp/ under the format of:
        agent_only_bigip_<test>_<year><month><day><hour><minute><second>.diff
    Example:
        /tmp/agent_only_bigip_test_foo_20170703222353.diff
        for test_foo() at 2017/07/03 22:23:53 or 10:23:53 PM
    Time stamps for this are captured at compile time, not during runtime or
    at file generation time, so it is expected that the creation date may
    differ from the timestamp in the filename.  This was chosen due to wanting
    all files generated in a single test run to have the same timestamp.
"""


class BigIpInteraction(object):
    """Class of simple class methods that open interaction with BIG-IP

    This class assumes that you are in testenv and that there is a BIG-IP
    configured for test runner's use.
    """
    config_file = "/tmp/agent_only_bigip_{}.cfg"
    diff_file = '/tmp/agent_only_bigip_{}_{}.diff'
    dirty_file = '/tmp/agent_only_bigip_dirty_{}_{}.cfg'
    _lbs_to_delete = []
    ssh_cmd = \
        str("ssh -F {} openstack_bigip").format(ssh_cfg)
    __extract_cmd = '''{} << EOF
tmsh -c \"cd /;
list sys folder recursive one-line" | cut -d " " -f3 |
while read f; do echo \"====================\";
echo \"Folder $f\"; tmsh -c "cd /$f; list\"; done;
exit
EOF'''
    __ucs_cmd_fmt = "{} tmsh {} /sys ucs /tmp/backup.ucs"

    @staticmethod
    def __exec_shell(stdin, shell=False):
        """Protected method for internal use"""
        Result = namedtuple('Result', 'stdout, stdin, stderr, exit_status')
        try:
            stdout = subprocess.check_output(stdin, shell=shell)
            stderr = ''
            exit_status = 0
        except subprocess.CalledProcessError as error:
            stderr = str(error)
            stdout = error.output
            exit_status = error.returncode

        return Result(stdout, stdin, stderr, exit_status)

    @staticmethod
    def __check_results(results):
        if results.exit_status:
            raise RuntimeError(
                "Could not extract bigip data!\nstderr:'{}'"
                ";stdout'{}' ({})".format(results.stderr, results.stdout,
                                          results.exit_status))

    @classmethod
    def _get_current_bigip_cfg(cls):
        """Get and return the current BIG-IP Config

        This method will perform the action of collecting BIG-IP config data.
        """
        results = cls.__exec_shell(
            cls.__extract_cmd.format(cls.ssh_cmd), shell=True)
        cls.__check_results(results)
        return results.stdout

    @classmethod
    def _get_existing_bigip_cfg(cls):
        """Extracts the BIG-IP config and stores it within instance

        This method will hold a copy of the existing BIG-IP config for later
        comparison.
        """
        result = cls._get_current_bigip_cfg()
        with open(cls.config_file.format(my_epoch), 'w') as fh:
            fh.write(result)

    @classmethod
    def _resulting_bigip_cfg(cls, test_method):
        """Checks the resulting BIG-IP config as it stands against snap shot

        This method will raise upon discovery of a polluted config against snap
        shot.  Upon a raise, it will also:
            * restore from backup
            * Sleep 5 seconds to asssure the BIG-IP is ready for REST cmds
            * Generate a diff file against the polluted config
        """
        try:
            with open(cls.config_file.format(my_epoch)) as fh:
                content = fh.read()
            diff_file = cls.__collect_diff(content, test_method)
            os.remove(diff_file)
        except AssertionError as err:
            cls.__restore_from_backup()
            sleep(5)  # after nuke, BIG-IP needs a delay...
            raise AssertionError(
                "BIG-IP cfg was polluted by test!! (diff: {})".format(err))

    @classmethod
    def _collect_diff(cls):
        """An accessible diff collection without a frame.

        This method can force the collection of a diff at any time during the
        testing process and does not necessarily require a difference between
        snapshot and current BIG-IP config.
        """
        result = cls._get_current_bigip_cfg()
        try:
            diff_file = cls.__collect_diff(result)
        except AssertionError as err:
            diff_file = str(err)
        return diff_file

    @classmethod
    def __collect_diff(cls, result, test_method):
        """An internal method"""
        dirty_file = cls.dirty_file.format(test_method, my_epoch)
        with open(dirty_file, 'w') as fh:
            fh.write(result)
        diff_file = cls.diff_file.format(test_method, my_epoch)
        cmd = "diff -u {} {} > {}".format(
            cls.config_file.format(my_epoch), dirty_file, diff_file)
        result = cls.__exec_shell(cmd, True)
        cls.__check_results(result)
        if os.path.getsize(diff_file) > 0:
            raise AssertionError(diff_file)
        return diff_file

    @classmethod
    def check_symbols(cls):
        if hasattr(pytest, 'symbols') and \
                hasattr(pytest.symbols, 'bigip_mgmt_ip_public'):
            cls.ssh_cmd = "ssh {}@{}".format(
                pytest.symbols.bigip_ssh_username,
                pytest.symbols.bigip_mgmt_ip_public)

    @classmethod
    def check_resulting_cfg(cls, test_name=current_test):
        """Check the current BIG-IP cfg agianst previous Reset upon Error

        This classmethod will check the current BIG-IP config and raise if
        there are any changes from the previous snap-shot.  Upon raise, the
        method will attempt to clear the BIG-IP back to the previous config

        test_name := the name of the test currently in tearDown
        """
        cls.check_symbols()
        cls._resulting_bigip_cfg(test_name)

    @classmethod
    def backup_bigip_cfg(cls):
        """Performs a config backup of the BIG-IP's configuration

        This method will store a backup of the BIG-IP's configuration on the
        BIG-IP for later restoration.
        """
        if not os.path.isfile(cls.config_file.format(my_epoch)):
            cls.check_symbols()
            cls.__exec_shell(
                cls.__ucs_cmd_fmt.format(cls.ssh_cmd, 'save'), True)
            cls._get_existing_bigip_cfg()


@pytest.fixture
def track_bigip_cfg(request):
    global current_test
    request.addfinalizer(BigIpInteraction.check_resulting_cfg)
    BigIpInteraction.backup_bigip_cfg()
    current_test = request.node.name  # current test's scoped name
